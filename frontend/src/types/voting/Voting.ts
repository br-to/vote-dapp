/* Autogenerated file. Do not edit manually. */
/* tslint:disable */

import type {
	AddressLike,
	BaseContract,
	BigNumberish,
	BytesLike,
	ContractMethod,
	ContractRunner,
	EventFragment,
	FunctionFragment,
	Interface,
	Listener,
	Result,
} from "ethers";
import type {
	TypedContractEvent,
	TypedContractMethod,
	TypedDeferredTopicFilter,
	TypedEventLog,
	TypedListener,
	TypedLogDescription,
} from "./common";

export interface VotingInterface extends Interface {
	getFunction(
		nameOrSignature:
			| "getAllVotes"
			| "getVotes"
			| "hasVoted"
			| "options"
			| "vote",
	): FunctionFragment;

	getEvent(nameOrSignatureOrTopic: "Voted"): EventFragment;

	encodeFunctionData(
		functionFragment: "getAllVotes",
		values?: undefined,
	): string;
	encodeFunctionData(functionFragment: "getVotes", values: [string]): string;
	encodeFunctionData(
		functionFragment: "hasVoted",
		values: [AddressLike],
	): string;
	encodeFunctionData(
		functionFragment: "options",
		values: [BigNumberish],
	): string;
	encodeFunctionData(functionFragment: "vote", values: [string]): string;

	decodeFunctionResult(
		functionFragment: "getAllVotes",
		data: BytesLike,
	): Result;
	decodeFunctionResult(functionFragment: "getVotes", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "hasVoted", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "options", data: BytesLike): Result;
	decodeFunctionResult(functionFragment: "vote", data: BytesLike): Result;
}

export namespace VotedEvent {
	export type InputTuple = [voter: AddressLike, option: string];
	export type OutputTuple = [voter: string, option: string];
	export interface OutputObject {
		voter: string;
		option: string;
	}
	export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
	export type Filter = TypedDeferredTopicFilter<Event>;
	export type Log = TypedEventLog<Event>;
	export type LogDescription = TypedLogDescription<Event>;
}

export interface Voting extends BaseContract {
	connect(runner?: ContractRunner | null): Voting;
	waitForDeployment(): Promise<this>;

	interface: VotingInterface;

	queryFilter<TCEvent extends TypedContractEvent>(
		event: TCEvent,
		fromBlockOrBlockhash?: string | number | undefined,
		toBlock?: string | number | undefined,
	): Promise<Array<TypedEventLog<TCEvent>>>;
	queryFilter<TCEvent extends TypedContractEvent>(
		filter: TypedDeferredTopicFilter<TCEvent>,
		fromBlockOrBlockhash?: string | number | undefined,
		toBlock?: string | number | undefined,
	): Promise<Array<TypedEventLog<TCEvent>>>;

	on<TCEvent extends TypedContractEvent>(
		event: TCEvent,
		listener: TypedListener<TCEvent>,
	): Promise<this>;
	on<TCEvent extends TypedContractEvent>(
		filter: TypedDeferredTopicFilter<TCEvent>,
		listener: TypedListener<TCEvent>,
	): Promise<this>;

	once<TCEvent extends TypedContractEvent>(
		event: TCEvent,
		listener: TypedListener<TCEvent>,
	): Promise<this>;
	once<TCEvent extends TypedContractEvent>(
		filter: TypedDeferredTopicFilter<TCEvent>,
		listener: TypedListener<TCEvent>,
	): Promise<this>;

	listeners<TCEvent extends TypedContractEvent>(
		event: TCEvent,
	): Promise<Array<TypedListener<TCEvent>>>;
	listeners(eventName?: string): Promise<Array<Listener>>;
	removeAllListeners<TCEvent extends TypedContractEvent>(
		event?: TCEvent,
	): Promise<this>;

	getAllVotes: TypedContractMethod<
		[],
		[[bigint, bigint] & { votesA: bigint; votesB: bigint }],
		"view"
	>;

	getVotes: TypedContractMethod<[option: string], [bigint], "view">;

	hasVoted: TypedContractMethod<[arg0: AddressLike], [boolean], "view">;

	options: TypedContractMethod<[arg0: BigNumberish], [string], "view">;

	vote: TypedContractMethod<[option: string], [void], "nonpayable">;

	getFunction<T extends ContractMethod = ContractMethod>(
		key: string | FunctionFragment,
	): T;

	getFunction(
		nameOrSignature: "getAllVotes",
	): TypedContractMethod<
		[],
		[[bigint, bigint] & { votesA: bigint; votesB: bigint }],
		"view"
	>;
	getFunction(
		nameOrSignature: "getVotes",
	): TypedContractMethod<[option: string], [bigint], "view">;
	getFunction(
		nameOrSignature: "hasVoted",
	): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
	getFunction(
		nameOrSignature: "options",
	): TypedContractMethod<[arg0: BigNumberish], [string], "view">;
	getFunction(
		nameOrSignature: "vote",
	): TypedContractMethod<[option: string], [void], "nonpayable">;

	getEvent(
		key: "Voted",
	): TypedContractEvent<
		VotedEvent.InputTuple,
		VotedEvent.OutputTuple,
		VotedEvent.OutputObject
	>;

	filters: {
		"Voted(address,string)": TypedContractEvent<
			VotedEvent.InputTuple,
			VotedEvent.OutputTuple,
			VotedEvent.OutputObject
		>;
		Voted: TypedContractEvent<
			VotedEvent.InputTuple,
			VotedEvent.OutputTuple,
			VotedEvent.OutputObject
		>;
	};
}
